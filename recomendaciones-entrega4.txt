Con base al punto anterior, es OBLIGATORIO:

La comunicación entre los servicios DEBE HACERSE usando comandos y eventos. Eso significa que NO debe haber llamados síncronos entre los servicios usando gRPC o HTTP. Usted debe crear los tópicos de comando para las acciones y los tópicos de eventos para propagar los eventos de integración o carga de estado. 

El enunciado menciona: "Elabore en el diseño del esquema, desde la tecnología hasta la evolución de los mismos ¿Avro o Protobuf? ¿Event Stream Versioning?". Ello significa que usted DEBE manejar un sistema de versionamiento y evolución de esquemas ¿Cuál? Esa es su decisión como arquitecto. Es decir, puede usar el Schema Registry de Apache Pulsar o uno externo, puede crear su propio sistema de versionamiento, etc. El formato de los mensajes: Avro, protobuf, JSON, parquet, etc Usted debe decidir lo mejor para su arquitectura y justificarlo. 

Usar Apache Pulsar como broker de eventos. 

El desarrollo de AL MENOS UN MICRO-SERVICIO usando Python y los frameworks aprendidos, tales como Flask, FastAPI, SQLAlchemy, entre otros. Un ejemplo de código que puede usar como base lo puede encontrar en el repositorio del 
tutorial 7
.

3 de los 4 servicios deben tener una base de datos. Estos pueden usar un modelo CRUD o Event Sourcing, o ambos ¡Usted define!. Por ejemplo, usted podría tomar la decisión de no usar Event Sourcing y que toda interacción sea CRUD. O por el contrario, puede decidir que los 3 servicios a implementar sean por medio de Event Sourcing. En tal caso, muestre como manejar las proyecciones y consultas. Así mismo, NO se espera que usted implemente toda una base de datos inmensa, puede ser tan fácil como una o dos tablas que eventualmente van a ser parte de una transacción larga. Su propósito no es probar requerimientos funcionales, sino los no-funcionales. 

El enunciado menciona: "justificó e implementó alguna de las topologías para la administración de datos: descentralizada o híbrida". Eso quiere decir que usted debe usar alguna de estas topologías o ambas y justificar su decisión. Si usa híbridas en el video y arquitectura debe ser claro como agrupa 

Links al repositorio de acceso público (por lo que evite poner credenciales o datos sensibles) y un documento de README con explicaciones adicionales acerca de su proyecto (escenarios de calidad a probar, estructura del proyecto, como desplegar los servicios en caso de ser necesario, etc).

Link con un video en formato mp4, mov, wmv o avi de NO más de 45 minutos con los requerimientos solicitados. Deje este video de acceso público para que tanto tutores como profesor tengan acceso. Si el archivo  tiene una duración mayor a 45 minutos, el tutor está en la potestad de dejar de ver el video una vez se cumpla el tiempo establecido. 

Recuerde que este es un curso donde DDD es la filosofía central de diseño. Por tal motivo, usted DEBE usar los patrones, tácticas y métodos aprendidos durante el curso. Deben ser claros los principios de DDD en el diseño: agregaciones, contextos acotados, inversión de dependencias, capas, arquitectura cebolla, etc. No es una carrera acerca de usar todo lo visto en términos de DDD, pero conceptos como las entidades, objetos valor, agregaciones y modelo de dominio son claves para tener micro-servicios realmente desacoplados y por ende DEBEN ser parte de su solución.

Cualquier otro detalle que se mencione en el enunciado o rúbrica.

NO se espera tener los microservicios completamente desarrollados, solo los comandos, consultas e infraestructura necesaria (tablas, tópicos, repositorios, etc) para satisfacer los escenarios de calidad.

Atributos de calidad relevantes para el problema. No vale usar atributos "fáciles de probar" y que además no tengan ningún tipo de relevancia para el negocio. i.e Latencia para procesar una orden. La latencia del sistema no es lo mismo que la latencia de la operación. Queremos entregar paquetes rápido, pero que el sistema procese una orden en menos de 5 segundos vs 1 minuto no va a hacer una gran diferencia. Aquí es vital validar con los stakeholders (tutores y profesor) esas prioridades. Otros ejemplos de MALA EXPERIMENTACIÓN pueden ser:

Probar que Apache Pulsar sirve.

Cobertura de código mayor a x% (esta probando sus pruebas unitarias).

Se pudo agregar un nuevo método en menos de 1 día.

OPCIONAL: Para mejor entendimiento por parte de los tutores, puede diagramar su arquitectura e indicar las decisiones de diseño solicitadas en el enunciado como adjunto al documento de README.

Guía usando AeroAlpes
Si piensan en el ejemplo de AeroAlpes hay varios micro servicios: reservas, pagos, clientes, gds, maximización de precios, búsqueda y notificaciones, pero en una transacción larga de sagas como la de reservar, solo necesitaríamos los servicios de reservas, pagos y GDS. Por ende, en un POC yo desarrollaría esos 3 servicios para una transacción larga de reservar.

En este primer experimento (entrega 4) NO hago la transacción, pero tendría los servicios funcionales, cada uno con sus tópicos de comando y eventos. En tal caso uno podría pensar en algo como:

Reservas:

Tópico comando: Reservar

Tópico eventos: Eventos de reserva (este podría incluir varios tipos de eventos como reserva iniciada, reserva pagada, reserva aprobada, reserva confirmada, etc)

GDS:

Tópico comando: Confirmar reserva

Tópico eventos: Eventos de confirmación (este podría incluir varios tipos de eventos como reserva confirmada, reserva rechazada, reserva sobrevendida, etc)

Pagos:

Tópico comando: Pagar reserva

Tópico eventos: Eventos de confirmación (este podría incluir varios tipos de eventos como pagar reservar, revertir pago, etc)

En la entrega 4 haría que los servicios pudisesen oirse por medio de los tópicos de eventos, pero por ahora no deben reaccionar o al menos completar una transacción (eso es parte de la siguiente entrega).Ya en la entrega 5, crearía una saga para orquestar o coreografear la transacción larga de reservar y creería un BFF con un endpoint en GraphQL o REST que permite hacer una reserva. Este es el que le entregaría al tutor para probar por medio de un Collection de POSTMAN. Finalmente, sobre esa transacción larga evaluó los 3 escenarios de calidad que definí previamente, en el caso de AeroAlpes los escenarios eran:

Crecer el sistema ante una demanda exponencial: En tal caso aumento los llamados al endpoint de reservas y valido los resultados.

El sistema ante fallo de componentes de despliegue sigue proveyendo servicio: En tal caso degrado algún componente del sistema por ejemplo, en un cluster de Apache Pulsar tiro una región completa de servidores/brokers y evalúo si puedo seguir creando reservas.